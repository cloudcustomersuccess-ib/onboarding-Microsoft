/**
 * DB HELPERS: leer/escribir en Google Sheets como si fuera una BBDD.
 *
 * ✅ ROBUSTO: Validaciones claras y logs útiles para debugging.
 */

/**
 * ✅ Helper principal: abre el Spreadsheet
 * Valida que CONFIG.SPREADSHEET_ID existe y no está vacío.
 * Lanza error claro si falta o está mal configurado.
 *
 * @returns {Spreadsheet} El spreadsheet abierto
 * @throws {Error} Si CONFIG.SPREADSHEET_ID no está configurado o es inválido
 */
function getSpreadsheet_() {
  const id = CONFIG.SPREADSHEET_ID;

  // Validación estricta
  if (!id || String(id).trim() === "") {
    throw new Error(
      "CONFIG.SPREADSHEET_ID está vacío o no configurado. " +
      "Verifica config.gs y asegúrate de que CONFIG.SPREADSHEET_ID tiene un valor válido."
    );
  }

  // Log útil (solo si está definido, no loguear secrets)
  Logger.log("Opening spreadsheet with ID: %s", id);

  try {
    return SpreadsheetApp.openById(id);
  } catch (err) {
    throw new Error(
      `Error al abrir spreadsheet con ID "${id}": ${err.message || err}. ` +
      "Verifica que el ID es correcto y que el script tiene permisos de acceso."
    );
  }
}

/**
 * ✅ Helper: obtiene una sheet por nombre
 * Valida que el nombre existe y no está vacío.
 * Usa getSpreadsheet_() internamente para garantizar validaciones.
 *
 * @param {string} name - Nombre de la pestaña/sheet
 * @returns {Sheet} La sheet encontrada
 * @throws {Error} Si name está vacío o la sheet no existe
 */
function getSheet_(name) {
  // Validación del parámetro
  if (!name || String(name).trim() === "") {
    throw new Error("getSheet_(): el parámetro 'name' está vacío o no fue provisto.");
  }

  const ss = getSpreadsheet_(); // Usa helper robusto
  const sh = ss.getSheetByName(name);

  if (!sh) {
    throw new Error(
      `La pestaña "${name}" no existe en el spreadsheet. ` +
      `Verifica que la pestaña existe y que el nombre en CONFIG.SHEETS.* coincide exactamente.`
    );
  }

  return sh;
}

/**
 * ✅ Alternativa legacy (DEPRECADA): usar getSpreadsheet_() en su lugar
 * Mantenida solo para compatibilidad con código existente.
 * Se recomienda usar getSpreadsheet_() directamente.
 */
function db() {
  return getSpreadsheet_();
}

/**
 * Obtiene un mapa de headers: { "NombreColumna": columnIndex }
 * @param {Sheet} sheet - La sheet de la que leer headers
 * @returns {Object} Mapa de nombre de columna -> índice (1-indexed)
 */
function getHeaderMap_(sheet) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const map = {};
  headers.forEach((h, i) => {
    map[String(h).trim()] = i + 1;
  });
  return map;
}

/**
 * Encuentra la fila por ClienteID en una sheet.
 * Devuelve rowNumber (>=2) o -1 si no existe.
 */
function findRowByClienteId_(sheetName, clienteId) {
  const sh = getSheet_(sheetName);
  const hm = getHeaderMap_(sh);
  const col = hm["ClienteID"];
  if (!col) throw new Error(`La sheet ${sheetName} no tiene columna ClienteID`);

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return -1;

  const values = sh.getRange(2, col, lastRow - 1, 1).getValues().flat();
  const idx = values.findIndex(v => String(v).trim() === String(clienteId).trim());
  return idx === -1 ? -1 : (idx + 2);
}

/**
 * Lee una fila completa como objeto { header: value }
 */
function readRowAsObject_(sheetName, rowNumber) {
  const sh = getSheet_(sheetName);
  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
  const row = sh.getRange(rowNumber, 1, 1, sh.getLastColumn()).getValues()[0];
  const obj = {};
  headers.forEach((h, i) => {
    obj[String(h).trim()] = row[i];
  });
  return obj;
}

/**
 * Escribe un valor en un campo específico de una fila
 */
function writeField_(sheetName, rowNumber, fieldKey, value) {
  const sh = getSheet_(sheetName);
  const hm = getHeaderMap_(sh);
  const col = hm[fieldKey];
  if (!col) throw new Error(`Campo no existe en ${sheetName}: ${fieldKey}`);
  sh.getRange(rowNumber, col).setValue(value);
}

/**
 * Helper para timestamp actual formateado
 */
function now_() {
  return Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss");
}

/**
 * Auditoría (solo en Google Sheet)
 * Columnas: AuditId, ClienteID, FieldKey, OldValue, NewValue, Action, ActorUserId, ActorRole, Source, Timestamp, CorrelationId
 */
function auditLog_(entry) {
  const sh = getSheet_(CONFIG.SHEETS.AUDIT);
  sh.appendRow([
    entry.AuditId,
    entry.ClienteID,
    entry.FieldKey,
    entry.OldValue,
    entry.NewValue,
    entry.Action,
    entry.ActorUserId,
    entry.ActorRole,
    entry.Source,
    entry.Timestamp,
    entry.CorrelationId,
  ]);
}
// ===== IonConnections DB Helpers =====

function ionSheet_() {
  return getSheet_("IonConnections"); // usa tu helper getSheet_()
}

function ionConnFindByOrg_(orgId) {
  orgId = String(orgId || "").trim();
  if (!orgId) return null;

  const sh = ionSheet_();
  const values = sh.getDataRange().getValues();
  const headers = values[0];
  const idx = Object.fromEntries(headers.map((h, i) => [h, i]));

  for (let r = 1; r < values.length; r++) {
    if (String(values[r][idx.orgId]) === orgId) {
      return { row: r + 1, data: rowToObj_(headers, values[r]) };
    }
  }
  return null;
}

function ionConnUpsert_(orgId, patch) {
  const sh = ionSheet_();
  const now = now_(); // tu helper

  const existing = ionConnFindByOrg_(orgId);
  if (!existing) {
    const connectionId = `IONCONN-${Utilities.getUuid()}`;
    const rowObj = Object.assign({
      connectionId,
      orgId,
      createdAt: now,
      updatedAt: now,
      ionHostname: "",
      ionAccountId: "",
      tokenCiphertext: "",
      tokenLast4: "",
      status: "needs_reauth",
      lastValidatedAt: "",
      lastError: "",
    }, patch || {});

    appendRowByHeaders_(sh, rowObj); // si no tienes, lo hacemos luego
    return { action: "insert", connectionId };
  }

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
  const idx = Object.fromEntries(headers.map((h, i) => [h, i]));

  const updates = Object.assign({}, patch || {}, { updatedAt: now });
  Object.keys(updates).forEach((key) => {
    if (idx[key] == null) return;
    sh.getRange(existing.row, idx[key] + 1).setValue(updates[key]);
  });

  return { action: "update", connectionId: existing.data.connectionId };
}

function rowToObj_(headers, row) {
  const obj = {};
  headers.forEach((h, i) => obj[h] = row[i]);
  return obj;
}
function ionLock_(orgId) {
  const lock = LockService.getScriptLock();
  lock.waitLock(20000); // 20s
  return lock;
}
/**
 * appendRowByHeaders_(sheet, obj)
 * - Lee headers en fila 1
 * - Construye una nueva fila alineada a esos headers
 * - Si un header no está en obj, deja ""
 */
function appendRowByHeaders_(sheet, obj) {
  if (!sheet) throw new Error("appendRowByHeaders_: sheet requerido");
  obj = obj || {};

  const lastCol = sheet.getLastColumn();
  if (lastCol < 1) throw new Error("appendRowByHeaders_: sheet sin columnas");

  const headers = sheet
    .getRange(1, 1, 1, lastCol)
    .getValues()[0]
    .map(h => String(h).trim());

  const hasAnyHeader = headers.some(h => !!h);
  if (!hasAnyHeader) {
    throw new Error("appendRowByHeaders_: la fila 1 no tiene headers (nombres de columnas)");
  }

  const row = headers.map(h =>
    Object.prototype.hasOwnProperty.call(obj, h) ? obj[h] : ""
  );

  sheet.appendRow(row);
  return { ok: true, row: sheet.getLastRow() };
}